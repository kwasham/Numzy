#!/usr/bin/env bash
set -euo pipefail

# Numzy dev runner: brings up backend infra (Docker Compose) and starts frontend dev (pnpm)
# Usage:
#   ./scripts/run-be-fe.sh [--rebuild] [--fresh] [--no-frontend] [--no-db] [--no-wait] [--env-stub]
# Flags:
#   --rebuild     Force image rebuild
#   --fresh       Down existing stack with volumes first
#   --no-frontend Skip starting the frontend dev server
#   --no-db       Skip local Postgres profile (requires external DATABASE_URL)
#   --no-wait     Skip health / port wait loops (faster, less safe)
#   --env-stub    Generate a minimal .env stub if missing
# Notes:
#   - Uses root docker-compose.yml with profiles: infra, app, and optionally local-db
#   - Starts frontend dev in background and writes PID to frontend-dev.pid
#   - Registers a trap to stop the frontend dev process on exit

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
FRONTEND_DIR="$ROOT_DIR/frontend"
COMPOSE_FILE="$ROOT_DIR/docker-compose.yml"
ENV_FILE="$ROOT_DIR/.env"
FRONTEND_PID_FILE="$FRONTEND_DIR/frontend-dev.pid"

REBUILD=0
FRESH=0
NO_FE=0
NO_DB=0
NO_WAIT=0
ENV_STUB=0

while [[ ${1:-} ]]; do
  case "$1" in
    --rebuild) REBUILD=1 ;;
    --fresh) FRESH=1 ;;
    --no-frontend|--no-fe) NO_FE=1 ;;
    --no-db) NO_DB=1 ;;
    --no-wait) NO_WAIT=1 ;;
    --env-stub) ENV_STUB=1 ;;
    -h|--help)
      echo "Usage: $0 [--rebuild] [--fresh] [--no-frontend] [--no-db] [--no-wait] [--env-stub]"
      exit 0
      ;;
    *) echo "Unknown option: $1" && exit 1 ;;
  esac
  shift
done

# Pick docker compose command
if command -v docker-compose >/dev/null 2>&1; then
  DC=(docker-compose -f "$COMPOSE_FILE")
else
  DC=(docker compose -f "$COMPOSE_FILE")
fi

profiles=(--profile infra --profile app)
if [[ $NO_DB -eq 0 ]]; then
  profiles+=(--profile local-db)
fi

echo "[run-be-fe] Using compose file: $COMPOSE_FILE"

# --- Pre-flight checks -------------------------------------------------------
if [[ ! -f "$COMPOSE_FILE" ]]; then
  echo "[run-be-fe] ERROR: docker-compose.yml not found at $COMPOSE_FILE" >&2
  exit 1
fi

if [[ ! -f "$ENV_FILE" ]]; then
  if [[ $ENV_STUB -eq 1 ]]; then
    cat > "$ENV_FILE" <<'STUB'
# Minimal Numzy dev .env (generated by run-be-fe)
# Adjust values as needed.
SENTRY_DSN=
DATABASE_URL=sqlite+aiosqlite:///./app.db
REDIS_URL=redis://redis:6379/0
DRAMATIQ_BROKER_URL=redis://redis:6379/0
MINIO_ENDPOINT=minio:9000
MINIO_ACCESS_KEY=minioadmin
MINIO_SECRET_KEY=minioadmin
CLERK_SECRET_KEY=
NEXT_PUBLIC_API_BASE_URL=http://localhost:8000
NEXT_PUBLIC_SENTRY_DSN=
STUB
    echo "[run-be-fe] Created .env stub at $ENV_FILE"
  else
    echo "[run-be-fe] WARNING: .env not found (pass --env-stub to generate a stub)" >&2
  fi
fi

if [[ $NO_DB -eq 1 ]]; then
  if [[ -z "${DATABASE_URL:-}" ]]; then
    # If no env var, check inside .env for DATABASE_URL line (best-effort)
    if ! grep -q '^DATABASE_URL=' "$ENV_FILE" 2>/dev/null; then
      echo "[run-be-fe] WARNING: --no-db used but DATABASE_URL not set; API may fail if it expects Postgres." >&2
    fi
  fi
fi

if ! command -v curl >/dev/null 2>&1; then
  echo "[run-be-fe] WARNING: curl not found; health waits will rely on nc only." >&2
fi

# --- Helper functions --------------------------------------------------------
wait_for_port() {
  local host=$1 port=$2 label=$3 attempts=${4:-30}
  local i
  [[ $NO_WAIT -eq 1 ]] && return 0
  echo "[run-be-fe] Waiting for $label ($host:$port) ..."
  for ((i=1;i<=attempts;i++)); do
    if nc -z "$host" "$port" 2>/dev/null || (command -v curl >/dev/null 2>&1 && curl -sSf "http://$host:$port/" >/dev/null 2>&1); then
      echo "[run-be-fe] $label ready"
      return 0
    fi
    sleep 1
  done
  echo "[run-be-fe] WARNING: Timeout waiting for $label ($host:$port)" >&2
  return 1
}

cleanup() {
  if [[ -f "$FRONTEND_PID_FILE" ]]; then
    local pid
    pid=$(cat "$FRONTEND_PID_FILE" 2>/dev/null || echo "")
    if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
      echo "[run-be-fe] Stopping frontend dev (PID $pid)"
      kill "$pid" 2>/dev/null || true
    fi
  fi
}
# Only clean up (stop frontend) on interrupt/termination, not normal exit
trap cleanup INT TERM

if [[ $FRESH -eq 1 ]]; then
  echo "[run-be-fe] Fresh start: docker compose down -v"
  "${DC[@]}" down -v --remove-orphans || true
fi

UP_FLAGS=(-d --remove-orphans)
if [[ $REBUILD -eq 1 ]]; then
  UP_FLAGS+=(--build)
fi

echo "[run-be-fe] Bringing up backend services (${profiles[*]})"
"${DC[@]}" "${profiles[@]}" up "${UP_FLAGS[@]}"

if [[ $NO_WAIT -eq 0 ]]; then
  # Core infra waits
  wait_for_port localhost 6379 Redis 30 || true
  wait_for_port localhost 9000 MinIO 30 || true
  if [[ $NO_DB -eq 0 ]]; then
    wait_for_port localhost 5432 Postgres 40 || true
  fi
  wait_for_port localhost 8000 API 40 || true
fi

if [[ $NO_FE -eq 0 ]]; then
  echo "[run-be-fe] Starting frontend dev server (pnpm dev)"
  if command -v pnpm >/dev/null 2>&1; then
    PKG_MGR=pnpm
  elif command -v npm >/dev/null 2>&1; then
    PKG_MGR=npm
  else
    echo "[run-be-fe] ERROR: Neither pnpm nor npm found in PATH" >&2
    exit 1
  fi

  export NEXT_TELEMETRY_DISABLED=1
  (
    cd "$FRONTEND_DIR"
    if [[ "$PKG_MGR" == "pnpm" ]]; then
      pnpm install
      nohup pnpm dev > frontend-dev.log 2>&1 & echo $! > frontend-dev.pid
    else
      npm install
      nohup npm run dev > frontend-dev.log 2>&1 & echo $! > frontend-dev.pid
    fi
  )
  echo "[run-be-fe] Frontend started. Logs: frontend/frontend-dev.log, PID: $(cat "$FRONTEND_DIR/frontend-dev.pid" 2>/dev/null || echo 'n/a')"
fi

cat <<EOF

[run-be-fe] Dev environment is up:
  - Frontend:   http://localhost:3000
  - API:        http://localhost:8000 (FastAPI docs usually at /docs)
  - MCP server: http://localhost:8002
  - Redis:      localhost:6379
  - MinIO:      http://localhost:9000 (console: :9001)
  - Postgres:   localhost:5432 (when --no-db not used)

Tips:
  - To view container logs: ${DC[*]} logs -f api worker mcp
  - To stop everything:     ${DC[*]} down --remove-orphans  # (frontend stops automatically on exit)
  - To nuke volumes:        ${DC[*]} down -v
  - To skip waits next run: add --no-wait

EOF
